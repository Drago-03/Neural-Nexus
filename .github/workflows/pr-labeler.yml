name: PR Labeler

on:
  pull_request:
    types: [opened, synchronize, edited]

jobs:
  label-pr:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Apply file-based labels
        uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/labeler.yml

      - name: Analyze PR and add custom labels
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const labels = [];
            const title = pr.title.toLowerCase();
            const body = pr.body ? pr.body.toLowerCase() : '';

            // Size-based labels
            const fileCount = files.length;
            const totalChanges = files.reduce((sum, file) => sum + file.changes, 0);

            if (fileCount <= 3 && totalChanges <= 50) {
              labels.push('size/XS');
            } else if (fileCount <= 10 && totalChanges <= 200) {
              labels.push('size/S');
            } else if (fileCount <= 25 && totalChanges <= 500) {
              labels.push('size/M');
            } else if (fileCount <= 50 && totalChanges <= 1000) {
              labels.push('size/L');
            } else {
              labels.push('size/XL');
            }

            // Type-based labels from title/description
            if (title.includes('fix') || title.includes('bug') || body.includes('fix')) {
              labels.push('type/bugfix');
            }
            if (title.includes('feat') || title.includes('feature') || body.includes('feature')) {
              labels.push('type/feature');
            }
            if (title.includes('docs') || title.includes('documentation')) {
              labels.push('type/documentation');
            }
            if (title.includes('refactor') || body.includes('refactor')) {
              labels.push('type/refactoring');
            }
            if (title.includes('test') || body.includes('test')) {
              labels.push('type/testing');
            }
            if (title.includes('perf') || title.includes('performance') || body.includes('performance')) {
              labels.push('type/performance');
            }
            if (title.includes('chore') || title.includes('maintenance')) {
              labels.push('type/chore');
            }
            if (title.includes('security') || body.includes('security')) {
              labels.push('type/security');
            }

            // Priority detection
            if (title.includes('urgent') || title.includes('critical') || body.includes('urgent')) {
              labels.push('priority/high');
            }
            if (title.includes('breaking') || body.includes('breaking change')) {
              labels.push('breaking-change');
            }

            // Component-based labels
            const componentFiles = files.filter(file => file.filename.startsWith('components/'));
            if (componentFiles.length > 0) {
              labels.push('area/components');
            }

            const apiFiles = files.filter(file => file.filename.includes('/api/'));
            if (apiFiles.length > 0) {
              labels.push('area/api');
            }

            const authFiles = files.filter(file => 
              file.filename.includes('auth') || 
              file.filename.includes('signin') || 
              file.filename.includes('signup')
            );
            if (authFiles.length > 0) {
              labels.push('area/auth');
            }

            const configFiles = files.filter(file => 
              file.filename.includes('.config.') || 
              file.filename.includes('package.json') ||
              file.filename.includes('tsconfig') ||
              file.filename.includes('.github/')
            );
            if (configFiles.length > 0) {
              labels.push('area/config');
            }

            // Dependency updates
            const dependencyFiles = files.filter(file => 
              file.filename === 'package.json' || 
              file.filename === 'package-lock.json' ||
              file.filename === 'yarn.lock'
            );
            if (dependencyFiles.length > 0) {
              labels.push('dependencies');
            }

            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labels
              });
            }

            // Comment with analysis
            const analysis = `## ðŸ“Š PR Analysis
            
            **Size:** ${fileCount} files changed, ${totalChanges} total changes
            **Labels added:** ${labels.join(', ') || 'None'}
            
            **Files modified:**
            ${files.slice(0, 10).map(file => 
              `- \`${file.filename}\` (+${file.additions}, -${file.deletions})`
            ).join('\n')}
            ${files.length > 10 ? `\n... and ${files.length - 10} more files` : ''}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: analysis
            });
